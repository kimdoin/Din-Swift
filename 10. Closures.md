# 1. Closures
* `Closure`는 비교적 짧고 독립적인 코드 조각이다.
* `Closure`에는 Function, Nested Function, Anonymous Function이 있다.
* Named Closures에는 Function과 Nested Function이 있다.
* Anonymous Function를 Unnamed Closure, 익명함수라고 한다.
* 자료형(Type)을 표현하는 방법은 함수와 완전히 동일하다. Function과 Closure는 서로 호환된다.
* Global Scope에서 단독으로 작성할 수 없기 때문에 상수나 변수에 저장해 사용해야 한다.
* **Closure를 호출할 땐 Argument Label을 사용하지 않는다.**
```swift
{ (parameters) -> ReturnType in
    statements
} 

{ statements } // 가장 단순한 클로저 표현식

let a = { print("Hello, blog") }
a() // Hello, blog

// 파라미터와 리턴형이 있는 클로저
let a2 = { (str: String) -> String in
    return "Hello, \(str)" // str은 파라미터 이름입니다.
}
let call = a2("blog")
print(call) // Hello, blog

// 클로저를 파라미터로 전달
typealias strClosure = (String) -> (String)
func printHello(closure: strClosure) {
    print(closure("iOS"))
}

printHello { (str: String) -> (String) in
    return "Hi, \(str)"
} // Hi, iOS
```
# 2. Syntax Optimiztion(문법 최적화)
* 불필요한 요소를 생략하고 단순하게 작성하는 것을 문법 최적화라고 한다.
* parameter와 return형을 생략할 수 있다.
* parameter 이름을 Shorthand Argument Name($0...)을 대체할 수 있다. 
* `{ }` 사이에 단일 리턴 문만 

{ } 사이에 단일 리턴 문만 남아있을 경우 리턴 키워드를 생략합니다.
클로저 파라미터가 마지막 파라미터라면 트렐링 클로저로 작성합니다.
괄호 사이에 파라미터가 없으면 괄호를 삭제합니다.


parameter와 return형 in을 생략할 수 있다.

parameter이름을 Shorthand Argument Name($문자와 숫자의 조합)으로 대체할 수 있다.

Shorthand Argument Name에서 parameter는 숫자로 대체할 수 있다.
대체되는 숫자는 0부터 시작된다. $0 $1 $2...
단일 리턴문만 남아있을 경우 return Keyword를 생략한다. (Implicit Returns)

Closure parameter가 마지막 parameter라면, In-line Closure가 아닌, Trailing Closure로 작성한다.

()에 다른 parameter가 없다면, ()도 생략해준다. 만약 Argument Label이 있다면 삭제한다.

문법최적화에서 parameter를 사용하지 않을거라면, _ in 으로 대체해주어야 한다.


